# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' LOOE
#' 
#' This function performs ...
#' 
#' @param X ......
#' @param Y ...
#' @param paral ...
#' @param nl ...
#' @param ml ...
#' @param l ...
#' @return coef ...
#' @return Ginv  ...
#' @return lambda.min  ...
#' @return lambdas  ...
#' @return looe ...
#' @examples
#' n <- 500
#' p <- 200
#' M <- matrix(rnorm(n*p), nrow=n, ncol=p)
#' Y <- 2.4*M[,1] + 1.6*M[,2] - 0.4*M[,5]
#' 
#' MD <- DelayedArray(M)
#' YD <- DelayedArray(as.matrix(Y))
#' 
#' looe <- LOOE(M,Y,paral=TRUE),
#' looe_delayed <- LOOE(MD,YD,paral=TRUE)
#' 
#' looe$lambda.min
#' looe$lambdas
#' looe_delayed$coef[1:10]
#' @export
LOOE <- function(X, Y, paral, nl = NULL, ml = NULL, l = NULL) {
    .Call('_BigDataStatMeth_LOOE', PACKAGE = 'BigDataStatMeth', X, Y, paral, nl, ml, l)
}

#' Normalize Delayed Array matrix
#' 
#' This function performs a numerical or Delayed Array matrix normalization
#' 
#' @param X numerical or Delayed Array Matrix
#' @param bcenter logical (default = TRUE) if TRUE, centering is done by subtracting the column means
#' @param bscale logical (default = TRUE) if TRUE, centering is done by subtracting the column means
#' @return numerical matrix
#' @examples
#' m <- 500
#' n <- 100 
#' x <- matrix(rnorm(m*n), nrow=m, ncol=n)
#' 
#' # with numeric matrix
#' Normalize_Data(x)
#' 
#' # with Delaeyd Array
#' Dx <- DelayedArray(x)
#' 
#' # Center and scale
#' Normalize_Data(Dx)
#' 
#' # Only scale
#' Normalize_Data(Dx, bcenter = FALSE)
#' 
#' # Only center
#' Normalize_Data(Dx, bscale = FALSE)
#' 
#' @export
Normalize_Data <- function(x, bcenter = NULL, bscale = NULL) {
    .Call('_BigDataStatMeth_Normalize_Data', PACKAGE = 'BigDataStatMeth', x, bcenter, bscale)
}

ols_grid <- function(X, y, l, r, m, t, mb, tb) {
    .Call('_BigDataStatMeth_ols_grid', PACKAGE = 'BigDataStatMeth', X, y, l, r, m, t, mb, tb)
}

matv_gemv <- function(M, V) {
    .Call('_BigDataStatMeth_matv_gemv', PACKAGE = 'BigDataStatMeth', M, V)
}

matv_gemm <- function(a, b) {
    .Call('_BigDataStatMeth_matv_gemm', PACKAGE = 'BigDataStatMeth', a, b)
}

matv_dtrsv <- function(M, v) {
    .Call('_BigDataStatMeth_matv_dtrsv', PACKAGE = 'BigDataStatMeth', M, v)
}

matv_dtrsm <- function(R, Z) {
    .Call('_BigDataStatMeth_matv_dtrsm', PACKAGE = 'BigDataStatMeth', R, Z)
}

matm_dtrtri <- function(R) {
    .Call('_BigDataStatMeth_matm_dtrtri', PACKAGE = 'BigDataStatMeth', R)
}

#' Crossproduct and transposed crossproduct of DelayedArray
#' 
#' This function performs a crossproduct or transposed crossproduct of numerical or DelayedArray matrix.
#' 
#' @param X numerical or Delayed Array matrix
#' @param transposed (optional, default = false) boolean indicating if we have to perform a crossproduct (transposed=false) or transposed crossproduct (transposed = true)
#' @return numerical matrix with crossproduct or transposed crossproduct 
#' @examples
#' n <- 100
#' p <- 60
#' 
#' X <- matrix(rnorm(n*p), nrow=n, ncol=p)
#' 
#' # without DelayedArray
#' bdcrossprod(X)
#' bdcrossprod(X, transposed = TRUE)
#' 
#' # with DelayedArray
#' XD <- DelayedArray(X)
#' bdcrossprod(XD)
#' bdcrossprod(XD, transpoded = TRUE)
#' 
#' @export
bdcrossprod <- function(a, transposed = NULL) {
    .Call('_BigDataStatMeth_bdcrossprod', PACKAGE = 'BigDataStatMeth', a, transposed)
}

#' Matrix - Weighted vector Multiplication with numerical or DelayedArray data
#' 
#' This function performs a weighted product of a matrix(X) with a weighted diagonal matrix (w)
#' 
#' @param X numerical or Delayed Array matrix
#' @param w vector with weights
#' @param op string indicating if operation  "Xw" or "wX"
#' @param bparal (optional, default = true) if bparal=true performs parallel computation.
#' @return numerical matrix 
#' @examples
#' n <- 100
#' p <- 60
#' 
#' X <- matrix(rnorm(n*p), nrow=n, ncol=p)
#' 
#' u <- runif(n)
#' w <- u * (1 - u)
#' bdwproduct(X, w,"xtwx")
#' bdwproduct(X, w,"xwxt")
#' 
#' # with Delayed Array
#' 
#' DX <- DelayedArray(X)
#' dw <- DelayedArray(w)
#' 
#' bdwproduct(DX, dw,"xtwx")
#' bdwproduct(DX, dw,"xwxt")
#' 
#' @export
bdwproduct <- function(a, w, op) {
    .Call('_BigDataStatMeth_bdwproduct', PACKAGE = 'BigDataStatMeth', a, w, op)
}

bdXwd <- function(X, w, op, bparal = NULL) {
    .Call('_BigDataStatMeth_bdXwd', PACKAGE = 'BigDataStatMeth', X, w, op, bparal)
}

#' Block matrix multiplication with Delayed Array Object
#' 
#' This function performs a block matrix-matrix multiplication with numeric matrix or Delayed Arrays
#' 
#' @param a a double matrix.
#' @param b a double matrix.
#' @param block_size (optional, defalut = 128) block size to make matrix multiplication, if `block_size = 1` no block size is applied (size 1 = 1 element per block)
#' @param paral, (optional, default = TRUE) if paral = TRUE performs parallel computation else performs seria computation
#' @return numerical matrix
#' @examples
#' # with numeric matrix
#' m <- 500
#' k <- 1500
#' n <- 400
#' A <- matrix(rnorm(n*p), nrow=n, ncol=k)
#' B <- matrix(rnorm(n*p), nrow=k, ncol=n)
#' 
#' blockmult(A,B,128, TRUE)
#' 
#' # with Delaeyd Array
#' AD <- DelayedArray(A)
#' BD <- DelayedArray(B)
#' 
#' blockmult(AD,BD,128, TRUE)
#' 
#' @export
blockmult <- function(a, b, block_size = NULL, paral = NULL) {
    .Call('_BigDataStatMeth_blockmult', PACKAGE = 'BigDataStatMeth', a, b, block_size, paral)
}

CholFactor <- function(a) {
    .Call('_BigDataStatMeth_CholFactor', PACKAGE = 'BigDataStatMeth', a)
}

CholSolve <- function(a, b) {
    .Call('_BigDataStatMeth_CholSolve', PACKAGE = 'BigDataStatMeth', a, b)
}

inversechol_par <- function(a) {
    .Call('_BigDataStatMeth_inversechol_par', PACKAGE = 'BigDataStatMeth', a)
}

partCrossProd <- function(X) {
    .Call('_BigDataStatMeth_partCrossProd', PACKAGE = 'BigDataStatMeth', X)
}

partCrossProd_block <- function(X) {
    .Call('_BigDataStatMeth_partCrossProd_block', PACKAGE = 'BigDataStatMeth', X)
}

parCrossProd <- function(X) {
    .Call('_BigDataStatMeth_parCrossProd', PACKAGE = 'BigDataStatMeth', X)
}

parCrossProd_block <- function(X) {
    .Call('_BigDataStatMeth_parCrossProd_block', PACKAGE = 'BigDataStatMeth', X)
}

partCrossProdEigen <- function(X) {
    .Call('_BigDataStatMeth_partCrossProdEigen', PACKAGE = 'BigDataStatMeth', X)
}

#' Matrix multiplication with Delayed Array Object (RcppParallel)
#' 
#' This function performs a block matrix-matrix multiplication with numeric matrix or Delayed Arrays
#' 
#' @param a a double matrix.
#' @param b a double matrix.
#' @param op, (optional, default = "xy"), if op="xy" then performs the x\%*\%y matrix multiplication, if op = "xty" preforms t(X)\%*\% Y, if op = "xyt" performs X\%*\%t(Y)
#' @return numerical matrix
#' @examples
#' # with numeric matrix
#' m <- 500
#' k <- 300
#' n <- 400
#' A <- matrix(rnorm(n*p), nrow=n, ncol=k)
#' B <- matrix(rnorm(n*p), nrow=k, ncol=n)
#' 
#' parXYProd(A,B,128, TRUE)
#' 
#' # with Delaeyd Array
#' AD <- DelayedArray(A)
#' BD <- DelayedArray(B)
#' 
#' parXYProd(AD,BD,128, TRUE)
#' 
#' @export
parXYProd <- function(X, Y, op = NULL) {
    .Call('_BigDataStatMeth_parXYProd', PACKAGE = 'BigDataStatMeth', X, Y, op)
}

#' Block matrix multiplication with Delayed Array Object
#' 
#' This function performs a block matrix-matrix multiplication with numeric matrix or Delayed Arrays
#' 
#' @param a a double matrix.
#' @param b a double matrix.
#' @param op, (optional, default = "xy"), if op="xy" then performs the x\%*\%y matrix multiplication, if op = "xty" preforms t(X)\%*\% Y, if op = "xyt" performs X\%*\%t(Y)
#' @return numerical matrix
#' @examples
#' # with numeric matrix
#' m <- 500
#' k <- 1500
#' n <- 400
#' A <- matrix(rnorm(n*p), nrow=n, ncol=k)
#' B <- matrix(rnorm(n*p), nrow=k, ncol=n)
#' 
#' blockmult(A,B,128, TRUE)
#' 
#' # with Delaeyd Array
#' AD <- DelayedArray(A)
#' BD <- DelayedArray(B)
#' 
#' blockmult(AD,BD,128, TRUE)
#' 
#' @export
parXYProdBlock <- function(X, Y, op = NULL) {
    .Call('_BigDataStatMeth_parXYProdBlock', PACKAGE = 'BigDataStatMeth', X, Y, op)
}

parxwxt <- function(X, W) {
    .Call('_BigDataStatMeth_parxwxt', PACKAGE = 'BigDataStatMeth', X, W)
}

parxtwx <- function(X, W) {
    .Call('_BigDataStatMeth_parxtwx', PACKAGE = 'BigDataStatMeth', X, W)
}

parXy <- function(X, Y) {
    .Call('_BigDataStatMeth_parXy', PACKAGE = 'BigDataStatMeth', X, Y)
}

JacobianSVD <- function(X) {
    .Call('_BigDataStatMeth_JacobianSVD', PACKAGE = 'BigDataStatMeth', X)
}

bdtsvd <- function(X, k = NULL) {
    .Call('_BigDataStatMeth_bdtsvd', PACKAGE = 'BigDataStatMeth', X, k)
}

bdsvd <- function(X) {
    .Call('_BigDataStatMeth_bdsvd', PACKAGE = 'BigDataStatMeth', X)
}

#' Pseudo-Inverse
#' 
#' Compute the pseudo-inverse of a singular matrix
#' 
#' @param Singular matrix (m x n)
#' @return Pseudo-inverse matrix of A
#' @export
bdpseudoinv <- function(X) {
    .Call('_BigDataStatMeth_bdpseudoinv', PACKAGE = 'BigDataStatMeth', X)
}

#' QR Decomposition 
#' 
#' This function compute QR decomposition (also called a QR factorization) 
#' of a matrix \code{A} into a product \code{A = QR} of an 
#' orthogonal matrix Q and an upper triangular matrix R.
#' 
#' @param X a real square matrix 
#' @param boolean thin, if thin = true returns Q thin  decomposition else returns Q full decomposition, default thin = false
#' @return List with orthogonal matrix \code{Q}  and upper triangular matrix \code{R}
#' @export
bdQR <- function(X, thin = NULL) {
    .Call('_BigDataStatMeth_bdQR', PACKAGE = 'BigDataStatMeth', X, thin)
}

review_decomposition <- function(R, n) {
    .Call('_BigDataStatMeth_review_decomposition', PACKAGE = 'BigDataStatMeth', R, n)
}

#' Solves matrix equations : A*X = B
#' 
#' 
#' 
#' @param R numerical or Delayed Array matrix. 
#' @param Z numerical or Delayed Array matrix.
#' @return X numerical matrix. 
#' @examples
#' 
#' @export
bddtrsm <- function(R, Z) {
    .Call('_BigDataStatMeth_bddtrsm', PACKAGE = 'BigDataStatMeth', R, Z)
}

#' SVD of DelayedArray 
#' 
#' This function performs a svd decomposition of numerical matrix or Delayed Array
#' 
#' @param x numerical or Delayed Array matrix
#' @param k number of eigen values , this should satisfy k = min(n, m) - 1
#' @param nev (optional, default nev = n-1) Number of eigenvalues requested. This should satisfy 1≤ nev ≤ n, where n is the size of matrix. 
#' @param bcenter (optional, defalut = TRUE) . If center is TRUE then centering is done by subtracting the column means (omitting NAs) of x from their corresponding columns, and if center is FALSE, no centering is done.
#' @param bscale (optional, defalut = TRUE) .  If scale is TRUE then scaling is done by dividing the (centered) columns of x by their standard deviations if center is TRUE, and the root mean square otherwise. If scale is FALSE, no scaling is done.
#' @return u eigenvectors of AA^t, mxn and column orthogonal matrix
#' @return v eigenvectors of A^tA, nxn orthogonal matrix
#' @return d singular values, nxn diagonal matrix (non-negative real values)
#' @examples
#' n <- 500
#' A <- matrix(rnorm(n*n), nrow=n, ncol=n)
#' AD <- DelayedArray(A)
#' 
#' # svd without normalization
#' bdSVD( A, bscale = FALSE, bcenter = FALSE ), # No matrix normalization
#' decsvd$d
#' decsvd$u
#' 
#' # svd with normalization
#' decvsd <- bdSVD( A, bscale = TRUE, bcenter = TRUE), # Matrix normalization
#' 
#' decsvd$d
#' decsvd$u
#' 
#' # svd with scaled matrix (sd)
#' decvsd <- bdSVD( A, bscale = TRUE, bcenter = FALSE), # Scaled matrix
#' 
#' decsvd$d
#' decsvd$u
NULL

#' # svd with centered matrix (sd)
#' decvsd <- bdSVD( A, bscale = FALSE, bcenter = TRUE), # Centered matrix
#' decsvd$d
#' decsvd$u
NULL

#' Inverse Cholesky of Delayed Array
#' 
#' This function get the inverse of a numerical or Delayed Array matrix. If x is hermitian and positive-definite matrix then 
#' performs get the inverse using Cholesky decomposition
#' 
#' 
#' @param x numerical or Delayed Array matrix. If x is Hermitian and positive-definite performs
#' @return inverse matrix of d 
#' @examples
#' 
#' A <- matrix(c(3,4,3,4,8,6,3,6,9), byrow = TRUE, ncol = 3)
#' bdInvCholesky(A)
#' 
#' # with Delayed Array
#' DA <- DelayedArray(A)
#' bdInvCholesky(DA)
#' 
#' @export
bdInvCholesky <- function(x) {
    .Call('_BigDataStatMeth_bdInvCholesky', PACKAGE = 'BigDataStatMeth', x)
}

#' 
#' @export
bdSVD <- function(x, k = 0L, nev = 0L, bcenter = TRUE, bscale = TRUE) {
    .Call('_BigDataStatMeth_bdSVD', PACKAGE = 'BigDataStatMeth', x, k, nev, bcenter, bscale)
}

