---
title: "LOOE"
author:
- name: Dolors Pelegrí-Sisó 
  affiliation: Universitat Autònoma de Barcelona (UAB)
- name: Juan R Gonzalez
  affiliation: Barcelona Institute for Global Health (ISGlobal)
  email: juanr.gonzalez@isglobal.org
abstract: |
  
date: "`r Sys.Date()`"
#output: 
#  rmarkdown::html_vignette:
#    theme: Architect:
#    toc_float: true
output:
  BiocStyle::html_document:
    toc_float: true
    
pages:
  markdown:
    extra: true
    
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "", cache = TRUE, 
  warning=FALSE, message=FALSE 
)
```


# Prerequisites


# Overview

<!-- AQUÍ FER SECCIONS PRINCIPALS AMB : 
  - Operacions bàsiques amb matrius:
      . Producte de matrius
      . Matriu x vector
      . Crossprod i tCrossprod
      . ...
  - Algebra lineal:
      . svd
      . inversa matrius
      . ...
  - Aplicació algebra lineal:
      . PCA
      . OLS-GRID
      . ...
-->

# Matrix Multiplication

## Simple matrix multiplication (withou blocks) :

If you want to perform a simple sequential matrix multiplication you can call the function `blockmult()` with DelayedArray data type or any other R data type. In the example bellow we perform a product with A(500x500) and B(500x750).

```{r librarydef }
library(BigDataStatMeth)
library(DelayedArray)
n <- 500
p <- 750

A <- matrix(rnorm(n*n), nrow=n, ncol=n)
B <- matrix(rnorm(n*p), nrow=n, ncol=p)
DA <- DelayedArray(A) # Get A as Delayed Array
DB <- DelayedArray(B) # Get B as Delayed Array

AxB <- blockmult(A, B)
AxBDelay <- blockmult(DA, DB)

AxBDelay [1:5,1:5]

all.equal(AxB, AxBDelay)
all.equal(A%*%B, AxBDelay)

```

you can optimize the performance making this calculus in parallel with `paral=true` .  

```{r noblockmultparal}

AxB <- blockmult(A, B, paral = TRUE)
AxBDelay <- blockmult(DA, DB, paral = TRUE) # using Delayed Array data type

all.equal(AxB, AxBDelay)

```


## Block matrix multiplication

A block matrix or a partitioned matrix is a matrix that is interpreted as having been broken into sections called blocks or submatrices. Intuitively, a matrix interpreted as a block matrix can be visualized as the original matrix with a collection of horizontal and vertical lines,
which break it up, or partition it, into a collection of smaller matrices [(more information on block matrix multiplication)](https://en.wikipedia.org/wiki/Block_matrix).

The code bellow performs a matrix multiplication with A(500x500) and B(500x750) with (10x10) blocks. 

```{r blockmult }

AxB <- blockmult(A, B, block_size = 10)
AxBDelay <- blockmult(DA, DB, block_size = 10 )

all.equal(AxBDelay,A%*%B)
all.equal(AxB, AxBDelay)


```

if block_size > cols(A) and rows(A) and cols(B) and rows(B) then blocks_size is set to min( ols(A), rows(A), cols(B), rows(B)) 

Like in simple matrix multiplication you can make operations in parallel with `paral = TRUE` .

```{r blockmultparal }

AxB <- blockmult(A, B, block_size = 10, paral = TRUE)
AxBDelay <- blockmult(DA, DB, block_size = 10, paral = TRUE )

all.equal(AxBDelay,A%*%B)
all.equal(AxB, AxBDelay)

```


# Cross-product and Transposed Cross-product

To perform a cross-product $C = A^t A$ you can call `bdcrossprod()`.

```{r crossprod }
n <- 500
m <- 250
A <- matrix(rnorm(n*m), nrow=n, ncol=m)
DA <- DelayedArray(A)

# Cross Product
cpA <- bdcrossprod(A, transposed = FALSE)  
cpDA <- bdcrossprod(DA)  # With DelayedArray data type and no transposed parameter

all.equal(cpDA, crossprod(A))
```

you may also set `transposed=TRUE` (default value transposed=false) to perform a Transposed Cross-product $C = A A^t$

```{r nocrossprod }
# Transposed Cross Product
tcpA <- bdcrossprod(A, transposed = TRUE)
tcpDA <- bdcrossprod(DA, transposed = TRUE) # With DelayeArray data type

all.equal(tcpDA, tcrossprod(A))

```

# Matrix Vector Multiplication 

You can perform a weighted cross-product $C = X^ t w X$ with `bdwcrossprod()` given a matrix X as argument and a vector or matrix of weights, w. 

## Weighted Cross-product and Weighted Transposed Cross-product

```{r wcrossprod }
n <- 250
X <- matrix(rnorm(n*n), nrow=n, ncol=n)
u <- runif(n)
w <- u * (1 - u)
DX <- DelayedArray(X)
Dw <- DelayedArray(as.matrix(w))
  
wcpX <- bdwproduct(X, w,"xwxt")
wcpDX <- bdwproduct(DX, Dw,"xwxt") # with DelayedArray

wcpDX[1:5,1:5]

all.equal( wcpDX, X%*%diag(w)%*%t(X) )

```

## Weighted Transposed Cross Product 

With argument `transposed=TRUE`, we can perform a transposed weighted cross-product $C = A w A^t$  

```{r wtcrossprod }

wtcpX <- bdwproduct(X, w,"xtwx")
wtcpDX <- bdwproduct(DX, Dw,"xtwx") # with DelayedArray

wtcpDX[1:5,1:5]

all.equal(wtcpDX, t(X)%*%diag(w)%*%X)

```

# Inverse Cholesky
<p> The Cholesky factorization is widely used for solving a system of linear equations whose coefficient matrix is symmetric and positive definite.</p>
<p style="text-align: center;">$A = LL^t = U^tU$ </p>
where $L$ is a lower triangular matrix and U is an upper triangular matrix.
To get the Inverse Cholesky we can use the function `bdInvCholesky()`


```{r invChols }

# Generate a positive definite matrix
Posdef <- function (n, ev = runif(n, 0, 10)) 
{
  Z <- matrix(ncol=n, rnorm(n^2))
  decomp <- qr(Z)
  Q <- qr.Q(decomp) 
  R <- qr.R(decomp)
  d <- diag(R)
  ph <- d / abs(d)
  O <- Q %*% diag(ph)
  Z <- t(O) %*% diag(ev) %*% O
  return(Z)
}

A <- Posdef(n = 500, ev = 1:500)
DA <- DelayedArray(A)

invchol <- bdInvCholesky(A)
Dinvchol <- bdInvCholesky(DA)

round(invchol[1:5,1:5],8)

all.equal(Dinvchol, solve(A))

```

# SVD Decomposition

<p>The singular-value decomposition of an $mxn$ real or complex matrix $A$ is a factorization of the form :</p>
<p style="text-align: center;">$U\Sigma { V }^{ T }$</p>
where : 
$U$ is a $mxm$ real or complex unitary matrix
$\Sigma $ is a $mxn$ rectangular diagonal matrix with non-negative real numbers on the diagonal
$V$ is a $nxn$ real or complex unitary matrix.
The diagonal entries $\sigma_i$ of $\Sigma$ are known as the singular values of $A$
The columns of $U$ are called the left-singular vectors of $A$
The columns of $V$ are called the right-singular vectorsof $A$

## svd

The svd decomposition can be performed with the function `BDsvd()`, with BDsvd you can only perform a svd from real matrix $A$.  Given matrix A as argument 

```{r svd_default}
n <- 500
A <- matrix(rnorm(n*n), nrow=n, ncol=n)
DA <- DelayedArray(A)

bsvd <- BDsvd(A)
Dbsvd <- BDsvd(DA)

bsvd$d[1:10]
bsvd$u[1:5,1:5]
bsvd$v[1:5,1:5]

all.equal( sqrt( svd( tcrossprod( scale(A) ) )$d[1:10] ), bsvd$d[1:10] ) 
all.equal( sqrt( svd( tcrossprod( scale(A) ) )$d[1:10] ), Dbsvd$d[1:10] )

```

you get the $\sigma_i$, $U$ and $V$ of normalized matrix $A$, if you want to perform the SVD from not normalized matrix $A$ then you have to set the parameter `normalize = false`

```{r svd_nonorm}
bsvd <- BDsvd(A, normalize = FALSE)
Dbsvd <- BDsvd(DA, normalize = FALSE)

bsvd$d[1:10]
bsvd$u[1:5,1:5]
bsvd$v[1:5,1:5]

all.equal( sqrt(svd(tcrossprod(A))$d[1:10]), bsvd$d[1:10] ) 
all.equal( sqrt(svd(tcrossprod(A))$d[1:10]), Dbsvd$d[1:10] )
  
```



# LOOE - Leave One Out Error


# Ols-grid







# Session information

```{r sesinfo }
sessionInfo()
```

